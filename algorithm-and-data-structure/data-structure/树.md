### 树

##### 概念

节点的度：子节点的数量

树的度：最大的节点的度

存储：first children & next sibling -> 二叉树







### 二叉树

##### 性质

$n_0$为叶节点个数，$n_1$为度为1的节点个数，$n_2$为度为2的节点个数

$n_0=n_2+1$，证明：$n_0+n_1+n_2-1=|E|=0\times n_0+1\times n_1+2\times n_2$

##### 遍历

画一圈轮廓，第一次碰到打印是前序，第二次碰到是中序，第三次碰到是后序；叶节点三次同时碰到

两种遍历确定二叉树：必须有中序（原因：先序为根左右，无法确定左右的边界，后序同）。确定方法：先序的第一个为根，在中序中找到根得到左右子树，在先序中确定左右子树，递归。



##### 非递归遍历算法（中序为例）

遇到一个结点,就把它压栈,并去遍历它的左子树;
当左子树遍历结束后,从栈顶弹出这个结点并访问它;
然后按其右指针再去中序遍历该结点的右子树。

```C
void InOrderTraversal(BinTree BT){
    BinTree T=BT;
    Stack S= CreatStack(Maxsize);/*创建并初始化堆栈s*/
    while(T || !IsEmpty(s)){
        while(T){/*一直向左并将沿途结点压入堆栈*/
            Push(S, T);  // meet the node for the first time
            // printf("%5d", T->Data);  PreOrder
            T=T->Left;
        }
        if(!IsEmpty(S)){
            T=Pop(s);/*结点弹出堆栈*/ // meet the node for the second time
            printf("%5d", T->Data);/*(访问)打印结点*/
            T=T->Right;/*转向右子树*/
        }
    }
}
```











### 完全二叉树

定义：叶节点最多只出现在最底层和次底层，而且最底层的叶节点都连续集中在最左边，
每个内部节点都有两个子节点，最多可有1个节点例外

左→右，上→下 从1编号，则编号为p的节点左子节点为2p，右子节点为2p+1，父节点为$[\frac{p}{2}]$

Proper binary tree：每个节点有两个或零个叶节点







### 小顶堆

定义：完全二叉树；任何一个节点，其父节点的值小于其值

- 加入时放末尾，仅影响末位到根的路径上的次序，对其不断交换上浮即可

- 删除后把末尾的放到根处，然后选择子节点较小的那个方向交换下沉

- 由列表生成堆：逐个插入复杂度$O(n\log n)$，对非叶节点交换下沉复杂度$O(n)$



### 哈夫曼树

每次把权值最小的两棵二叉树合并（可用堆实现），建树复杂度nlogn

##### 特点：

是proper二叉树（没有度为1的节点）

n个叶节点的哈夫曼树有2n-1个节点





### 二叉查找树(Binary Search Tree)

定义：比父节点小的都在左子树，大的都在右子树

特性：同样的数据，插入顺序不同，树结构不同

删除节点：

- 该节点没有子节点：直接删除

- 该节点有1个子节点：将唯一的子节点上移，替换被删节点

  需要讨论

  - 被删节点的子节点是左还是右子节点？
  - 被删节点本身是其父节点的左还是右子节点？
  - 被删节点本身就是根节点？

- 该节点有2个子节点：找另一个合适的节点替换被删节点，其值为被删节点的下一个，即被删节点右子树中最小的，被称为后继(successor)

  后继最多只有一个叶节点(本身是叶节点或者有右子树，不可能有左子树)