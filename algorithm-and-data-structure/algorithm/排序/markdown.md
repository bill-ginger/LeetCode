# 排序算法

### 冒泡排序

- 算法：进行多趟交换，每趟对每对比较交换。第一趟把最大的归位，n-1趟完成
- 复杂度：比对$O(n^2)$，交换$O(n^2)$

- 优点：不需要额外空间

  ​			 仅操作相邻元素，可在多种数据结构上实现(如链表)

- 优化：如果某趟比对无交换发生，则可提前结束

### 选择排序

- 优化版冒泡排序，复杂度：比对$O(n^2)$，交换$O(n)$
- 算法：每趟仅一次交换，记录最大项位置再与最后一项交换



### 插入排序

- 算法：维持一个已排好序的子列表，其位置始终在列表的前部，然后逐步扩大这个子列表直到全表

  ​			 第m趟时前m个已经排好序，把第m+1个冒泡到前m个的正确位置

- 复杂度：比对最坏$O(n^2)$，最好$O(n)$（已排好）

### Shell排序

- 算法：对间隔为k的子列表进行插入排序，$k=\frac{n}{2},\frac{n}{4},\frac{n}{8}...,1$

- 复杂度：$O(n^\frac{3}{2})$左右



### 归并排序

- 算法：
  - 将左右两半分别进行归并排序，放在新变量当中
  - 两个指针遍历将排好序的左右两半从小到达放到列表中，再把两半里还有剩的一般全部加进来
- 复杂度：$O(n\log n)$
- 缺点：需要额外一倍的空间



### 快速排序

- 算法：

  - 设置中值为第一个元素的值，改变中值的位置，使中值左边都小于中值，中值右边都大于中值，需在O(n)内完成。接下来对左边一半和右边一般分别进行快速排序

  - 改变中值位置的方法：

    设置左右标，左标向右移动,右标向左移动

    - 左标一直向右移动,碰到比中值大的就停止
    - 右标一直向左移动,碰到比中值小的就停止
    - 然后把左右标所指的数据项交换

    继续移动，直到左标移到右标的右侧，停止移动

    这时右标所指位置就是“中值”应处的位置（由于取第一个元素为中值，且最终左边的要比中值小）

    将中值和这个位置交换

- 复杂度：$O(n\log n)$

- 缺点：中值选取使得一半始终没有数据时，退化到$O(n^2)$，中值使得恰好左右部分一样多时效果最好

- 优化：在头、尾、中间三点采样取中值